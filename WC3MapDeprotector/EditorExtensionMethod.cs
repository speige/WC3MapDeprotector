using CSharpLua;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Text.RegularExpressions;
using War3Net.Build;
using War3Net.Build.Audio;
using War3Net.Build.Environment;
using War3Net.Build.Info;
using War3Net.Build.Script;
using War3Net.Build.Widget;
using War3Net.CodeAnalysis.Jass;
using War3Net.CodeAnalysis.Jass.Syntax;
using War3Net.IO.Mpq;

namespace WC3MapDeprotector
{
    public class ScriptMetaData
    {
        private MapSounds sounds;

        public MapInfo Info { get; set; }
        public MapSounds Sounds
        {
            get
            {
                var result = sounds ?? new MapSounds(MapSoundsFormatVersion.v3);
                if (!result.Sounds.Any(x => x.FilePath == "\x77\x61\x72\x33\x6D\x61\x70\x2E\x77\x61\x76"))
                {
                    result.Sounds.Add(new Sound() { FilePath = "\x77\x61\x72\x33\x6D\x61\x70\x2E\x77\x61\x76", Name = "\x67\x67\x5F\x73\x6E\x64\x5F\x77\x61\x72\x33\x6D\x61\x70" });
                }
                return result;
            }
            set => sounds = value;
        }
        public MapCameras Cameras { get; set; }
        public MapRegions Regions { get; set; }
        public MapTriggers Triggers { get; set; }
        public MapCustomTextTriggers CustomTextTriggers { get; set; }
        public TriggerStrings TriggerStrings { get; set; }
        public MapUnits Units { get; set; }
        public MapDoodads Doodads { get; set; }

        public List<MpqKnownFile> ConvertToFiles()
        {
            var map = new Map() { Info = Info, Units = Units, Sounds = Sounds, Cameras = Cameras, Regions = Regions, Triggers = Triggers, TriggerStrings = TriggerStrings, CustomTextTriggers = CustomTextTriggers };
            try
            {
                return map.GetAllNativeFiles();
            }
            catch
            {
                return new List<MpqKnownFile>();
            }
        }
    }

    public static partial class JassTriggerExtensions
    {
        public static HashSet<string> NativeEditorFunctions
        {
            get
            {
                return new HashSet<string>(AutoGeneratedEditorFunctions);
            }
        }

        public static readonly HashSet<string> AutoGeneratedEditorFunctions;
        private static readonly Dictionary<Type, List<MemberInfo>> _jassParserASTNodeChildren;
        static JassTriggerExtensions()
        {
            AutoGeneratedEditorFunctions = new HashSet<string>() { "config", "main", "CreateAllUnits", "CreateAllItems", "CreateNeutralPassiveBuildings", "CreateNeutralHostileBuildings", "CreatePlayerBuildings", "CreatePlayerUnits", "InitCustomPlayerSlots", "InitGlobals", "InitCustomTriggers", "RunInitializationTriggers", "CreateRegions", "CreateCameras", "InitSounds", "InitCustomTeams", "InitAllyPriorities", "CreateNeutralPassive", "CreateNeutralHostile", "InitUpgrades", "InitTechTree", "CreateAllDestructables" };
            for (var playerIdx = 0; playerIdx <= 23; playerIdx++)
            {
                AutoGeneratedEditorFunctions.Add($"InitUpgrades_Player{playerIdx}");
                AutoGeneratedEditorFunctions.Add($"InitTechTree_Player{playerIdx}");
                AutoGeneratedEditorFunctions.Add($"CreateBuildingsForPlayer{playerIdx}");
                AutoGeneratedEditorFunctions.Add($"CreateUnitsForPlayer{playerIdx}");
            }

            var jassParserSyntaxTypes = new HashSet<Type>(typeof(JassCompilationUnitSyntax).Assembly.GetTypes().Where(x => x.Namespace.Equals("War3Net.CodeAnalysis.Jass.Syntax", StringComparison.InvariantCultureIgnoreCase)));
            _jassParserASTNodeChildren = jassParserSyntaxTypes.ToDictionary(x => x, astNodeType => astNodeType.GetMembers(BindingFlags.Public | BindingFlags.Instance).Where(property =>
            {
                var memberType = (property as FieldInfo)?.FieldType ?? (property as PropertyInfo)?.PropertyType;
                if (memberType == null)
                {
                    return false;
                }

                if (jassParserSyntaxTypes.Contains(memberType))
                {
                    return true;
                }

                if (memberType.IsGenericType && memberType.GenericTypeArguments.Any(x => jassParserSyntaxTypes.Contains(x)))
                {
                    return true;
                }

                return false;
            }).ToList());
        }

        [GeneratedRegex(@"^\s*function\s+(\w+)\s+takes", RegexOptions.IgnoreCase)]
        public static partial Regex Regex_JassFunctionDeclaration();

        [GeneratedRegex(@"^\s*call\s+(\w+)\s*\(", RegexOptions.IgnoreCase)]
        public static partial Regex Regex_JassFunctionCall();

        [GeneratedRegex(@"\s*(constant\s*)?(\S+)\s+(array\s*)?([^ \t=]+)\s*(=)?\s*(.*)", RegexOptions.IgnoreCase)]
        public static partial Regex Regex_ParseJassVariableDeclaration();

        public static Dictionary<IJassSyntaxToken, IJassSyntaxToken> JassAST_CreateChildToParentMapping(JassCompilationUnitSyntax compilationUnit)
        {
            var result = new Dictionary<IJassSyntaxToken, IJassSyntaxToken>();
            var allTokens = compilationUnit.GetChildren_RecursiveDepthFirst();
            foreach (var parent in allTokens)
            {
                foreach (var child in parent.GetChildren())
                {
                    result[child] = parent;
                }
            }

            return result;
        }

        public static void JassASTNode_ReplaceChild(IJassSyntaxToken parent_jassASTNode, IJassSyntaxToken oldChild_jassASTNode, params IJassSyntaxToken[] replacementChild_jassASTNodes)
        {
            var parentType = parent_jassASTNode.GetType();

            if (!_jassParserASTNodeChildren.TryGetValue(parentType, out var childrenProperties))
            {
                return;
            }

            foreach (var childProperty in childrenProperties)
            {
                object value = null;
                if (childProperty is PropertyInfo propertyInfo)
                {
                    value = propertyInfo.GetValue(parent_jassASTNode);
                    if (value == oldChild_jassASTNode)
                    {
                        if (replacementChild_jassASTNodes.Length > 1)
                        {
                            DebugSettings.Warn("Invalid JassASTNode_ReplaceChild params");
                        }

                        propertyInfo.SetValue(parent_jassASTNode, replacementChild_jassASTNodes[0]);
                    }
                }
                if (childProperty is FieldInfo fieldInfo)
                {
                    value = fieldInfo.GetValue(parent_jassASTNode);
                    if (value == oldChild_jassASTNode)
                    {
                        if (replacementChild_jassASTNodes.Length > 1)
                        {
                            DebugSettings.Warn("Invalid JassASTNode_ReplaceChild params");
                        }

                        fieldInfo.SetValue(parent_jassASTNode, replacementChild_jassASTNodes[0]);
                    }
                }

                if (value is System.Collections.IList list)
                {
                    var valueType = value.GetType();
                    var isImmutable = valueType.Name.StartsWith("Immutable") || valueType.Name.StartsWith("ReadOnly");
                    if (isImmutable)
                    {
                        list = list.Cast<object>().ToList();
                    }

                    var oldIndex = list.IndexOf(oldChild_jassASTNode);
                    if (oldIndex != -1)
                    {
                        list.RemoveAt(oldIndex);
                        foreach (var node in replacementChild_jassASTNodes.Reverse())
                        {
                            list.Insert(oldIndex, node);
                        }
                    }

                    if (isImmutable)
                    {
                        if (valueType.IsGenericType && valueType.Name.StartsWith(nameof(ImmutableArray) + "`"))
                        {
                            var childGenericType = valueType.GenericTypeArguments[0];
                            var genericList = list.ToGenericListOfType(childGenericType);
                            var methodInfo_toImmutableArray = typeof(ImmutableArray).GetMethods(BindingFlags.Public | BindingFlags.Static).First(x => x.Name == nameof(ImmutableArray.ToImmutableArray) && x.GetParameters()[0].ParameterType.GetGenericTypeDefinition() == typeof(IEnumerable<>)).MakeGenericMethod(childGenericType);
                            var immutableArray = methodInfo_toImmutableArray.Invoke(null, new[] { genericList });

                            if (childProperty is PropertyInfo listPropertyInfo)
                            {
                                listPropertyInfo.SetValue(parent_jassASTNode, immutableArray);
                            }
                            if (childProperty is FieldInfo listFieldInfo)
                            {
                                listFieldInfo.SetValue(parent_jassASTNode, immutableArray);
                            }
                        }
                        else
                        {
                            DebugSettings.Warn("Unknown readonly type");
                        }
                    }
                }
            }
        }

        public static void FindFirstMismatchedChildDueToJassPidginParsingBug(JassCompilationUnitSyntax original, JassCompilationUnitSyntax cloned)
        {
            if (!DebugSettings.IsDebugMode || !Debugger.IsAttached)
            {
                return;
            }

            var allChildren = original.GetChildren_RecursiveDepthFirst().ToArray();
            var allClonedChildren = cloned.GetChildren_RecursiveDepthFirst().ToArray();

            for (var idx = 0; idx  < allChildren.Length; idx++)
            {
                if (allChildren[idx].ToString() != allClonedChildren[idx].ToString())
                {
                    Debugger.Break();

                    using (var stream = new MemoryStream())
                    using (var writer = new StreamWriter(stream))
                    {
                        var renderer = new JassRenderer(writer);
                        renderer.Render(allChildren[idx]);
                    }

                    break;
                }
            }

            Debugger.Break();
        }
    }
}